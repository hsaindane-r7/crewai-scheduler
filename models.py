from datetime import datetime, timedelta
from typing import List, Optional

from pydantic import BaseModel, Field


class Goal(BaseModel):
    """High-level goal provided by the user."""

    title: str = Field(..., description="Short title of the goal")
    description: str = Field(..., description="Detailed description of what success looks like")
    due_date: Optional[datetime] = Field(
        default=None,
        description="Optional desired completion date for the overall goal",
    )


class SubTask(BaseModel):
    """Atomic step generated by the planner."""

    id: str = Field(..., description="Stable identifier for the task")
    goal_title: str = Field(..., description="Title of the parent goal")
    description: str = Field(..., description="What needs to be done")
    estimate_minutes: Optional[int] = Field(
        default=None,
        description="Estimated time to complete this task in minutes",
    )
    order: Optional[int] = Field(
        default=None,
        description="Relative ordering among all subtasks",
    )
    scheduled_start: Optional[datetime] = Field(
        default=None,
        description="When the task is planned to start",
    )
    scheduled_end: Optional[datetime] = Field(
        default=None,
        description="When the task is planned to finish",
    )


class Schedule(BaseModel):
    """A simple container for all planned subtasks."""

    goal: Goal
    subtasks: List[SubTask] = Field(default_factory=list)

    @property
    def total_estimated_minutes(self) -> int:
        return sum(t.estimate_minutes or 0 for t in self.subtasks)

    def with_time_blocks(
        self,
        start_time: Optional[datetime] = None,
        default_block_minutes: int = 30,
    ) -> "Schedule":
        """
        Return a new schedule with scheduled_start / scheduled_end filled in, using
        simple sequential blocks starting from start_time.
        """
        if start_time is None:
            start_time = datetime.now()

        current = start_time
        updated_subtasks: List[SubTask] = []

        for task in sorted(
            self.subtasks,
            key=lambda t: (t.order if t.order is not None else 9999, t.id),
        ):
            duration = timedelta(
                minutes=task.estimate_minutes or default_block_minutes
            )
            updated_subtasks.append(
                task.model_copy(
                    update={
                        "scheduled_start": current,
                        "scheduled_end": current + duration,
                    }
                )
            )
            current += duration

        return Schedule(goal=self.goal, subtasks=updated_subtasks)


